// 055 모듈 이해하기

/*
    모듈은 파일이나 코드의 묶음 단위로 애플리케이션 하나의 구성요소로 볼 수 있다.
    이렇게 모듈로 정의하면 모듈 단위로 코드를 재사용 할 수 있고, 하나의 애플리케이션이라는 큰 기능을 작은 기능 단위로 잘게 분리하여 관리 할 수 있다.
    예를 들어, 베이스볼 게임이라는 애플리케이션을 문제 생성 모듈, 플레이어 관리 모듈, 정답 채점 모듈 등과 같이 여러 모듈로 구성할 수 있다.

    ECMAScript 5.x 버전까지는 모듈에 대한 정의를 자바스크립트 표준으로 제공하지 않았습니다.
    그래서 네임스페이스 패턴을 통해 모듈을 정의했다.
    다음 예제를 통하여 네임스페이스 패턴을 알아보겠다

*/

var namespaceA = (function () {
    var privateVariable = '비공개 변수';
    return {
        publicAPi : function () {
            console.log(privateVariable + '를 접근할 수 있다.');
        }
    }
})();

namespaceA.publicAPi();

/**
    네임스페이스란 C# 언어에서 제공하는 기능으로 코드를 그룹화하고 이름 충돌을 방지하게 도와준다.
    하지만 자바스크립트에서는 네임스페이스를 직접적으로 지원하지 않는다
    그래서 함수를 정의함과 동시에 실행하는 즉각 호출 패턴을 통하여 네임스페이스를 유사하게 구현할 수 있다.
    이렇게 하는 이유는 기본적으로 변수와 함수를 선언하게 되면 전역으로 정의 되어 다른 라이브러리나 타인의 코드에서 정의된 이름들과 충돌이 날 수 있기 떄문이다.
    
    위 예제는 즉각  호출 패턴을 통해 함수를 정의함과 동시에 실행하여
    util이라는 네임스페이스를 생성하고 있다 
    var 키워드로 생성된 변수의 스크포는 함수이기 떄문에 네임스페이스 안에 정의된 변수들은 그 외부에 접근을 못한다

    즉각 호출 패턴인 ()(); 를 통하여 namespaceA의 변수에 함수에서 반환된 객체를 할당한다.

    함수 안에 선언된 변수는 함수 내부에서만 접근이 가능하기 떄문에 비공개 영역이 된다.

    반환되는 객체는 namespaceA에 할당되고, 외부에서 접근이 가능하기 떄문에 해당 객체의 속성과 메소드들은 공개 API가 된다.

    NOTE
    namespaceA 자체는 전역으로 등록되기 떄문에 여전히 이름 충돌이 발생할 수 있다.
    그리고 즉각 호출 패턴을 통해 정의된 다른 모듈을 사용하는 것 또한 전역을 통해 가져오게 되낟.
    이러한 문제점을 해결하기 위해 ES6 이전에는 RequireJS를 통하여모듈을 정의하였다.
    ES6에서 모듈 시스템에 대한 표준이 정의되었기 떄문에 RequireJS과 같은 별도의 라이브러리 필요ㅗ 없이 이러한 문제를 해결할 수 있다
    
 */